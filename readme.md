# Setup things
This is for me because I every time forget how to setup dev env on windows
![](/doc/images/main.png)

## Windows
1. Follow msys64 installation instructions here https://code.visualstudio.com/docs/languages/cpp#_example-install-mingwx64

    I ussually install it in ```d:\src\msys64``` folder

    a. So I download msys64 installer and run it
    
    b. The first command to run is ```pacman -S mingw-w64-ucrt-x86_64-gcc```
    
    c. Second command for the moment is ```pacman -S --needed base-devel mingw-w64-x86_64-toolchain``` default=all so to install everything because idk what exactly is needed
    
    d. Then adding to path is pain in the ass 
        
    ```D:\app\msys64\ucrt64\bin``` - For some unknow reasons
    
    ```D:\app\msys64\mingw64\bin``` - From tutorial
    
    ```D:\app\msys64\usr\bin``` - From docs
Usually this three paths solve everything

2. Second task is to setup cpp shared lib and include folder which I usuall setup in ```d:\src\cpp``` where two folders reside ```lib``` and ```include```
```
├───include
│   └───SDL2
└───lib
    ├───cmake
    │   └───SDL2
    └───pkgconfig
```
So for now I am a bit lazy to instruct how to download SDL libs and includes and organize in folder let us do ubuntu instead of it then

## Ubuntu
1. Of course ```sudo apt install g++```

2. ```sudo apt install libsdl2-dev```

3. ```sudo apt install libsdl2-image-dev libsdl2-ttf-dev```

    ```g++ -std=c++17 -O3 -m64 -Isrc  -s -o main main.cpp -lSDL2main -lSDL2 -lSDL2_image -lSDL2_ttf```


# How it works
Here is how animation works
![](/doc/images/animation.jpg)

We first start with preparing of Sprite in the scene ```prepare``` method where we have ```renderer``` instance present 
```c++
Sprite* sprite = new Sprite(
    new Image(renderer, "footman.png"),
    72, // Default frame width
    72, // Default frame height
    100, // Default frame pause
    true // Default sprite read orientation (true == vertical read)
);
```

Then let us define some constants somewhere:
```c++
// Define clip keys
const UNIT_MOVE_UP = 1;
const UNIT_MOVE_DOWN = 1;

sprite->addClip (
    UNIT_MOVE_UP, // Clip name index 
    1, // Start frame cell
    2, // Start frame row
    4, // Number of frames
    true, // Flip x of frame
    false // Flip y of frame
);

// Add some more clips
sprite->addClip (UNIT_MOVE_DOWN, 5, 2, 4);
sprite->addClip (UNIT_MOVE_RIGHT, 3, 2, 4);
sprite->addClip (UNIT_MOVE_LEFT, 3, 2, 4, true);

```

Now that we have sprite with four clips we can create dumb animation

```c++
animation = new Animation(
    sprite, // Our sprite
    UNIT_STAND_DOWN // Default clip from sprite
);
```

During scene update we can call

```c++
// The update will manage to play the clip frame by frame
// By configured delayes with respect to delta
animation->update(delta); // Where delta is provided in scene->update(delta)
```

And we render it somwhere in scene->render(...)
```c++
// Here goes some logic which manages the frame position on screen
SDL_rect position;

// And render the current active frame on screen
animation->render(&position);
```

# Map generation
Just generate map with x,y for cycle and random appeared to be too complex task, first of all big title games use procedural map generation using random noise which in its turn is a complex algorithm which was invented by some guy named Perlin for movie Tron and the algorithm was called Perlin Noise but eventually it was slow so he came up with new version of algorithm called Simplex Noise but patented it for 3 dimensional use, after which some dudes made OpenSimplexNoise

So first I searched C++ implementations of it, basically none of them work or did not work with C++ 17 standard or had to many dependencies, then after trials and errors one repo with 21 stars appeared to be promising but lacking examples

This is the initial noise:

![](/doc/images/noise1.gif)

Generated by:
```c++
srand(clock);
float intensity = 0.01;
OpenSimplexNoise::Noise noise{rand()}; // Init library with seed
int alpha;
for (int y=0; y<width; y++) {
    for (int x=0; x<height; x++)
    {
        // Use library to generate value for x,y 
        // And scale it from -1 .. 1 to 1 .. 255
        alpha = (noise.eval(x*intensity, y*intensity) + 1) / 2.0  * 255.0;
        minimap->setPixel(x, y, 255, 255, 255, alpha);       
    }
}
```

When the right path was visible I implemented minimap, so plan is that first we generate map plan aka minimap and based on minimap regular map is generated using sprites.

This is how minimap is generated in ```test_scene_perlin.hpp```:
```c++
class TestScenePerlin : public Scene {
    using Scene::Scene;
    Minimap* minimap;
    int ticks;
    public:
    virtual void prepare() {
        minimap = new Minimap(renderer, 512, 512, 1);
        objects.push_back(minimap);
    }
    void update(State* state) {
        if (SDL_GetTicks()-ticks>1000) {
            srand(clock());
            minimap->generateTerrain(rand(), 0.01, 6, TERRAIN_RANGES, TERRAIN_COLORS);
            ticks = SDL_GetTicks();
        }
    }
};
```
![](/doc/images/noise2.gif)

Where the different terrain colors and noise ranges are defined like this:

```c++
// We will have 6 terrain types
int TERRAIN_COLORS[6][3] = {
    {51, 51, 255},
    {0, 0, 255},
    {0, 153, 0},
    {255, 153, 51},
    {96, 96, 96},
    {255, 255, 255}
};

// And we declare noise range per terrain type
float TERRAIN_RANGES[6] = {
    0.3,
    0.35,
    0.5,
    0.7,
    0.9,
    1
};
```