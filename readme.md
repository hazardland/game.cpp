# Setup things
This is for me because I every time forget how to setup dev env on windows
![](/doc/images/main.png)

## Windows
1. Follow msys64 installation instructions here https://code.visualstudio.com/docs/languages/cpp#_example-install-mingwx64

    I ussually install it in ```d:\src\msys64``` folder

    a. So I download msys64 installer and run it
    
    b. The first command to run is ```pacman -S mingw-w64-ucrt-x86_64-gcc```
    
    c. Second command for the moment is ```pacman -S --needed base-devel mingw-w64-x86_64-toolchain``` default=all so to install everything because idk what exactly is needed
    
    d. Then adding to path is pain in the ass 
        
    ```D:\app\msys64\ucrt64\bin``` - For some unknow reasons
    
    ```D:\app\msys64\mingw64\bin``` - From tutorial
    
    ```D:\app\msys64\usr\bin``` - From docs
Usually this three paths solve everything

2. Second task is to setup cpp shared lib and include folder which I usuall setup in ```d:\src\cpp``` where two folders reside ```lib``` and ```include```
```
├───include
│   └───SDL2
└───lib
    ├───cmake
    │   └───SDL2
    └───pkgconfig
```
So for now I am a bit lazy to instruct how to download SDL libs and includes and organize in folder let us do ubuntu instead of it then

## Ubuntu
1. Of course ```sudo apt install g++```

2. ```sudo apt install libsdl2-dev```

3. ```sudo apt install libsdl2-image-dev libsdl2-ttf-dev```

    ```g++ -std=c++17 -O3 -m64 -Isrc -s -o main main.cpp src/game/*.cpp  -lSDL2main -lSDL2 -lSDL2_image -lSDL2_ttf```


# How it works
Here is how animation works
![](/doc/images/animation.jpg)

We first start with preparing of Sprite in the scene ```prepare``` method where we have ```renderer``` instance present 
```c++
Sprite* sprite = new Sprite(
    new Image(renderer, "footman.png"),
    72, // Default frame width
    72, // Default frame height
    100, // Default frame pause
    true // Default sprite read orientation (true == vertical read)
);
```

Then let us define some constants somewhere:
```c++
// Define clip keys
const UNIT_MOVE_UP = 1;
const UNIT_MOVE_DOWN = 1;

sprite->addClip (
    UNIT_MOVE_UP, // Clip name index 
    1, // Start frame cell
    2, // Start frame row
    4, // Number of frames
    true, // Flip x of frame
    false // Flip y of frame
);

// Add some more clips
sprite->addClip (UNIT_MOVE_DOWN, 5, 2, 4);
sprite->addClip (UNIT_MOVE_RIGHT, 3, 2, 4);
sprite->addClip (UNIT_MOVE_LEFT, 3, 2, 4, true);

```

Now that we have sprite with four clips we can create dumb animation

```c++
animation = new Animation(
    sprite, // Our sprite
    UNIT_STAND_DOWN // Default clip from sprite
);
```

During scene update we can call

```c++
// The update will manage to play the clip frame by frame
// By configured delayes with respect to delta
animation->update(delta); // Where delta is provided in scene->update(delta)
```

And we render it somwhere in scene->render(...)
```c++
// Here goes some logic which manages the frame position on screen
SDL_rect position;

// And render the current active frame on screen
animation->render(&position);
```

# Map generation
## Perlin Noise
Just generate map with x,y for cycle and random appeared to be too complex task, first of all big title games use procedural map generation using random noise which in its turn is a complex algorithm which was invented by some guy named Perlin for movie Tron and the algorithm was called Perlin Noise but eventually it was slow so he came up with new version of algorithm called Simplex Noise but patented it for 3 dimensional use, after which some dudes made OpenSimplexNoise

So first I searched C++ implementations of it, basically none of them work or did not work with C++ 17 standard or had to many dependencies, then after trials and errors one repo with 21 stars appeared to be promising but lacking examples

This is the initial noise:

![](/doc/images/noise1.gif)

Generated by:
```c++
srand(clock);
float intensity = 0.01;
OpenSimplexNoise::Noise noise{rand()}; // Init library with seed
int alpha;
for (int y=0; y<width; y++) {
    for (int x=0; x<height; x++)
    {
        // Use library to generate value for x,y 
        // And scale it from -1 .. 1 to 1 .. 255
        alpha = (noise.eval(x*intensity, y*intensity) + 1) / 2.0  * 255.0;
        terrain->setPixel(x, y, 255, 255, 255, alpha);       
    }
}
```

When the right path was visible I implemented minimap, so plan is that first we generate map plan aka minimap and based on minimap regular map is generated using sprites.

This is how terrain plan is generated in ```example_scene_map.hpp```:
```c++
class TestScenePerlin : public Scene {
    using Scene::Scene;
    Terrain* terrain;
    int ticks;
    public:
    virtual void prepare() {
        terrain = new Terrain(renderer, 512, 512, 1);
        objects.push_back(terrain);
    }
    void update(State* state) {
        if (SDL_GetTicks()-ticks>1000) {
            srand(clock());
            terrain->generate(rand(), 0.01, 6, TERRAIN_RANGES, TERRAIN_COLORS);
            ticks = SDL_GetTicks();
        }
    }
};
```
![](/doc/images/noise2.gif)

Where the different terrain colors and noise ranges are defined like this:

```c++
// We will have 6 terrain types
int TERRAIN_COLORS[6][3] = {
    {51, 51, 255},
    {0, 0, 255},
    {0, 153, 0},
    {255, 153, 51},
    {96, 96, 96},
    {255, 255, 255}
};

// And we declare noise range per terrain type
float TERRAIN_RANGES[6] = {
    0.3,
    0.35,
    0.5,
    0.7,
    0.9,
    1
};
```

## Tiled map smooth edges
Little did I know that biggest trouble was steal ahead: I grabbed Warcraft 2 map tile sprite and just converted terrain number into tail sprite frame number, added some terrain minimap to scroll over the map and this is what showed up:

![](/doc/images/map1.gif)

But this edges, they need to transition smoothly and there is no answer for that in the Google, so I started researching tile variations by myself. It appears these are the possible tile transitions if you transition it with only corner transition rule which just looks like an IQ test question:

![](/doc/images/transitions.png)

I need only blue ones because I eleminated 1 square layout

So I came up with complicated but nice algorithm I was lazy to check all cases and I risked my time just to implement it and the result was unbelivable also the algorithm run without error right in the first compilation:

![](/doc/images/map2.png)

So the map has 3 type of tiles water, ice and snowy ground and the algorithm calculates transitions between them and picks right tiles for it

The algirithm can be found in ```src/game/tile.hpp``` class

It took like couple of days but it was totally worth it, before commiting myself into it I made sure that it was a problem worth solving and I checked if other devs had trouble implementing it, it appears it is significant problem in 2d game developement and Factorio developers had various attempts to solve it https://www.factorio.com/blog/post/fff-344 here you can read more about their adventure